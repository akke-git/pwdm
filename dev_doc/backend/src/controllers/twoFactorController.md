# Two-Factor Authentication Controller (`twoFactorController.ts`)

이 컨트롤러는 시간 기반 일회용 비밀번호(TOTP)를 사용한 2단계 인증(2FA) 관련 기능을 관리합니다. 사용자가 2FA를 설정, 활성화, 비활성화하고, 인증 코드 및 백업 코드를 검증하는 로직을 포함합니다.

## 주요 의존성

-   `express`: 웹 프레임워크
-   `speakeasy`: TOTP 생성 및 검증 라이브러리
-   `qrcode`: TOTP 설정을 위한 QR 코드 생성 라이브러리
-   `bcrypt`: 백업 코드 해싱 라이브러리
-   `crypto`: 백업 코드 생성 시 랜덤 바이트 생성
-   `User` (models/index): 사용자 정보 조회 및 업데이트를 위한 Sequelize 모델

## 컨트롤러 함수 상세 설명

### 1. `setupTwoFactor`

-   **라우트**: (예상) `POST /2fa/setup`
-   **인증**: 필요
-   **설명**: 사용자를 위한 2FA 설정을 초기화합니다. 새로운 TOTP 비밀키를 생성하고, 이를 사용자의 인증 앱(예: Google Authenticator)에 등록할 수 있도록 QR 코드로 제공합니다.
-   **로직**:
    1.  현재 로그인한 사용자를 조회합니다.
    2.  사용자가 이미 2FA를 활성화한 경우 오류를 반환합니다.
    3.  `speakeasy.generateSecret`를 사용하여 새로운 2FA 비밀키(base32 인코딩)를 생성합니다.
    4.  생성된 비밀키를 사용자(`User`) 모델의 `twoFactorSecret` 필드에 저장합니다.
    5.  `QRCode.toDataURL`을 사용하여 인증 앱 등록을 위한 `otpauth_url` (비밀키 포함)을 QR 코드 이미지 데이터로 변환합니다.
    6.  성공 시 `200 OK` 상태와 함께 비밀키(base32)와 QR 코드 이미지 데이터를 반환합니다.

### 2. `enableTwoFactor`

-   **라우트**: (예상) `POST /2fa/enable`
-   **인증**: 필요
-   **설명**: 사용자가 `setupTwoFactor`를 통해 얻은 QR 코드를 인증 앱에 등록한 후, 해당 앱에서 생성된 TOTP 토큰을 검증하여 2FA를 최종적으로 활성화합니다. 활성화 시 10개의 일회용 백업 코드가 생성되어 사용자에게 제공됩니다.
-   **로직**:
    1.  요청 본문에서 TOTP 토큰(`token`)을 받습니다.
    2.  현재 로그인한 사용자를 조회합니다.
    3.  사용자가 이미 2FA를 활성화했거나, `twoFactorSecret`이 없는 경우(설정이 완료되지 않음) 오류를 반환합니다.
    4.  `speakeasy.totp.verify`를 사용하여 제공된 토큰과 사용자의 `twoFactorSecret`을 검증합니다.
    5.  검증 실패 시 오류를 반환합니다.
    6.  검증 성공 시, 10개의 새로운 백업 코드를 생성합니다:
        -   각 백업 코드는 `crypto.randomBytes`로 생성된 랜덤 문자열입니다.
        -   이 코드들은 `bcrypt.hash`를 사용하여 해시된 후, 쉼표로 구분된 문자열 형태로 `User` 모델의 `backupCodes` 필드에 저장됩니다.
    7.  사용자의 `twoFactorEnabled`를 `true`로 설정하고 저장합니다.
    8.  **주의**: 사용자에게 반환되는 백업 코드는 DB에 저장된 해시값의 원본이 아닌, 별도로 다시 생성된 10개의 랜덤 문자열입니다. (코드 line 131-135 참조). 이는 실제로는 DB에 저장된 코드와 매칭되지 않을 수 있으므로, 사용자에게 제공되는 백업 코드는 DB에 저장된 해시된 코드의 원본이어야 합니다. 현재 구현은 이 부분이 다를 수 있습니다.
    9.  성공 시 `200 OK` 상태와 함께 "2단계 인증이 성공적으로 활성화되었습니다." 메시지 및 (새로 생성된) 원본 백업 코드 목록을 반환합니다.

### 3. `disableTwoFactor`

-   **라우트**: (예상) `POST /2fa/disable`
-   **인증**: 필요
-   **설명**: 사용자의 2FA를 비활성화합니다. 이를 위해서는 유효한 TOTP 토큰과 사용자의 마스터 비밀번호를 모두 검증해야 합니다.
-   **로직**:
    1.  요청 본문에서 TOTP 토큰(`token`)과 마스터 비밀번호(`masterPassword`)를 받습니다.
    2.  현재 로그인한 사용자를 조회합니다.
    3.  2FA가 활성화되어 있지 않으면 오류를 반환합니다.
    4.  `user.validateMasterPassword`를 사용하여 제공된 마스터 비밀번호를 검증합니다.
    5.  `speakeasy.totp.verify`를 사용하여 제공된 TOTP 토큰을 검증합니다.
    6.  두 검증 중 하나라도 실패하면 오류를 반환합니다.
    7.  모두 성공 시, 사용자의 `twoFactorEnabled`를 `false`로 설정하고, `twoFactorSecret` 및 `backupCodes` 필드를 비웁니다.
    8.  성공 시 `200 OK` 상태와 함께 성공 메시지를 반환합니다.

### 4. `getTwoFactorStatus`

-   **라우트**: (예상) `GET /2fa/status`
-   **인증**: 필요
-   **설명**: 현재 사용자의 2FA 활성화 상태 및 설정 완료 여부(비밀키 존재 여부)를 반환합니다.
-   **로직**:
    1.  현재 로그인한 사용자를 조회합니다.
    2.  성공 시 `200 OK` 상태와 함께 `enabled` (boolean) 및 `setupComplete` (boolean, `twoFactorSecret` 유무) 값을 반환합니다.

### 5. `verifyBackupCode`

-   **라우트**: (예상) `POST /2fa/verify-backup`
-   **인증**: 필요 (주로 2FA 토큰을 사용할 수 없을 때 로그인 과정에서 사용)
-   **설명**: 사용자가 제공한 일회용 백업 코드를 검증합니다. 성공 시 해당 백업 코드는 사용된 것으로 처리되어 목록에서 제거됩니다.
-   **로직**:
    1.  요청 본문에서 백업 코드(`backupCode`)를 받습니다.
    2.  현재 로그인한 사용자를 조회합니다.
    3.  사용자에게 저장된 백업 코드(`user.backupCodes`)가 없으면 오류를 반환합니다.
    4.  저장된 백업 코드(쉼표로 구분된 해시 문자열)를 배열로 변환합니다.
    5.  제공된 `backupCode`와 저장된 각 해시된 코드를 `bcrypt.compare`를 사용하여 비교합니다.
    6.  일치하는 코드를 찾으면, 해당 코드를 백업 코드 목록에서 제거하고 `user.backupCodes`를 업데이트하여 저장합니다.
    7.  일치하는 코드가 없으면 오류를 반환합니다.
    8.  성공 시 `200 OK` 상태와 함께 성공 메시지 및 남은 백업 코드 수를 반환합니다.

### 6. `verifyTwoFactorToken`

-   **라우트**: (예상) `POST /2fa/verify-token`
-   **인증**: 필요 (로그인 시 또는 민감 작업 수행 전)
-   **설명**: 사용자가 제공한 현재 TOTP 토큰이 유효한지 검증합니다.
-   **로직**:
    1.  요청 본문에서 TOTP 토큰(`token`)을 받습니다.
    2.  현재 로그인한 사용자를 조회합니다.
    3.  2FA가 활성화되어 있지 않으면 오류를 반환합니다.
    4.  `speakeasy.totp.verify`를 사용하여 제공된 토큰과 사용자의 `twoFactorSecret`을 검증합니다. `window: 1` 옵션을 사용하여 시간 동기화 오차를 일부 허용합니다 (보통 전후 30초).
    5.  검증 실패 시 오류를 반환합니다.
    6.  성공 시 `200 OK` 상태와 함께 성공 메시지를 반환합니다.

## 보안 고려 사항

-   2FA 비밀키(`twoFactorSecret`)는 사용자의 인증 앱에만 저장되며, 서버에서는 이 키를 사용하여 토큰을 검증합니다. 이 키는 안전하게 보관되어야 합니다.
-   백업 코드는 해시되어 데이터베이스에 저장되므로, 원본 코드가 직접 노출되지 않습니다.
-   백업 코드는 일회용이며, 사용 시 즉시 무효화됩니다.
-   `enableTwoFactor` 함수에서 사용자에게 제공되는 백업 코드와 DB에 저장되는 해시된 코드의 원본이 일치하는지 확인하는 것이 중요합니다. 현재 코드(line 120-124 vs 131-135)는 이 부분에서 불일치 가능성이 있어 보입니다. 실제 운영 시에는 반드시 동일한 원본 코드가 사용자에게 제공되고, 그 원본이 해시되어 저장되어야 합니다.
